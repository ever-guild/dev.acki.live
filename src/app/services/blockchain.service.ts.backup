import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, map, catchError } from 'rxjs';
import { environment } from '../../environments/environment';

export interface Block {
  height: number;
  hash: string;
  timestamp: Date;
  txCount: number;
  miner: string;
  workchain_id?: number;
  shard?: string;
  seq_no?: number;
}

export interface Transaction {
  hash: string;
  from: string;
  to: string;
  amount: number;
  status: 'success' | 'pending' | 'failed';
  timestamp: Date;
}

export interface Message {
  id: string;
  sender: string;
  recipient: string;
  type: string;
  data: string;
  timestamp: Date;
}

export interface Contract {
  address: string;
  creator: string;
  created: Date;
  interactions: number;
  type: string;
}

export interface NetworkStats {
  totalBlocks: number;
  totalTransactions: number;
  hashrate: string;
  activeAddresses: number;
  avgBlockTime: string;
  difficulty: string;
  marketCap: string;
  price: string;
}

@Injectable({
  providedIn: 'root'
})
export class BlockchainService {
  
  getBlocks(): Observable<Block[]> {
    const blocks: Block[] = [];
    const now = Date.now();
    
    for (let i = 0; i < 20; i++) {
      blocks.push({
        height: 1234567 - i,
        hash: this.generateHash(),
        timestamp: new Date(now - i * 15000),
        txCount: Math.floor(Math.random() * 150) + 50,
        miner: this.generateAddress()
      });
    }
    
    return of(blocks);
  }

  getTransactions(): Observable<Transaction[]> {
    const transactions: Transaction[] = [];
    const now = Date.now();
    const statuses: ('success' | 'pending' | 'failed')[] = ['success', 'success', 'success', 'success', 'pending', 'failed'];
    
    for (let i = 0; i < 25; i++) {
      transactions.push({
        hash: this.generateHash(),
        from: this.generateAddress(),
        to: this.generateAddress(),
        amount: Math.random() * 100,
        status: statuses[Math.floor(Math.random() * statuses.length)],
        timestamp: new Date(now - i * 8000)
      });
    }
    
    return of(transactions);
  }

  getMessages(): Observable<Message[]> {
    const messages: Message[] = [];
    const now = Date.now();
    const types = ['Transfer', 'Stake', 'Unstake', 'Vote', 'Delegate', 'Claim'];
    
    for (let i = 0; i < 20; i++) {
      messages.push({
        id: this.generateHash().substring(0, 16),
        sender: this.generateAddress(),
        recipient: this.generateAddress(),
        type: types[Math.floor(Math.random() * types.length)],
        data: `{"amount": ${(Math.random() * 1000).toFixed(2)}}`,
        timestamp: new Date(now - i * 12000)
      });
    }
    
    return of(messages);
  }

  getContracts(): Observable<Contract[]> {
    const contracts: Contract[] = [];
    const now = Date.now();
    const types = ['ERC20', 'ERC721', 'DEX', 'Staking', 'DAO', 'Bridge'];
    
    for (let i = 0; i < 15; i++) {
      contracts.push({
        address: this.generateAddress(),
        creator: this.generateAddress(),
        created: new Date(now - i * 86400000 * Math.floor(Math.random() * 30)),
        interactions: Math.floor(Math.random() * 10000) + 100,
        type: types[Math.floor(Math.random() * types.length)]
      });
    }
    
    return of(contracts);
  }

  getStats(): Observable<NetworkStats> {
    return of({
      totalBlocks: 1234567,
      totalTransactions: 9876543,
      hashrate: '234.5 TH/s',
      activeAddresses: 45678,
      avgBlockTime: '15.2s',
      difficulty: '12.34T',
      marketCap: '$1.23B',
      price: '$2,345.67'
    });
  }

  private generateHash(): string {
    const chars = '0123456789abcdef';
    let hash = '0x';
    for (let i = 0; i < 64; i++) {
      hash += chars[Math.floor(Math.random() * chars.length)];
    }
    return hash;
  }

  private generateAddress(): string {
    const chars = '0123456789abcdef';
    let address = '0x';
    for (let i = 0; i < 40; i++) {
      address += chars[Math.floor(Math.random() * chars.length)];
    }
    return address;
  }
}
